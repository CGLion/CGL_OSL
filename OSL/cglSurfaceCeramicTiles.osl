#include "stdosl.h"

/*
TODO:
> Add spec input
> Add gloss coat layer
> Running bond?
> color tile var
> displace output
> tiling imperfections
> Cracks?
> make sure gloss coat doesnt get into grout

*/

vector getTiledCoords (vector coords, vector tiling)
{
	return vector ( fmod(coords[0],tiling[0])/tiling[0],
					fmod(coords[1],tiling[1])/tiling[1],
					fmod(coords[2],tiling[2])/tiling[2] );
}

float getTileGroutMask(vector groutSize, vector coords)
{
	float mask = coords[0] >= groutSize[0] && coords[0] <= 1 - groutSize[0];
	mask *= coords[1] >= groutSize[1] && coords[1] <= 1 - groutSize[1];
	return mask;
}

//<<< TODO >>> Make min angle param 
float getBevelAngle(float coords, float groutSize, float bevelSize)
{
	return coords < 0.5 ? clamp((coords - groutSize) / bevelSize,0.33,1.0) * M_PI_2 :
	clamp(((1 - coords) - groutSize) / bevelSize,0.33,1.0) * M_PI_2;
}

vector getBevelNormal(vector groutSize, vector bevelSize, vector coords, float multiplier)
{
	vector tan = dPdu;
	vector btan = dPdv;
	vector nrm = N;
	matrix TS = matrix( tan[0]	, tan[1]	, tan[2]	, 0.0,
						btan[0]	, btan[1]	, btan[2]	, 0.0,
						nrm[0]	, nrm[1]	, nrm[2]	, 0.0,
						0.0		, 0.0		, 0.0		, 1.0);
	vector angles = vector(0.0,0.0,0.0);
	//TODO: CHECK OPTION TO MAP INSTEAD OF CLAMP
	angles[0] = pow(getBevelAngle(coords[0], groutSize[0], bevelSize[0]),multiplier);
	angles[1] = pow(getBevelAngle(coords[1], groutSize[1], bevelSize[1]),multiplier);
	
	vector bevelVector = vector (	cos(angles[0]),
									cos(angles[1]),
									min(sin(angles[0]),sin(angles[1])));
	return transform(TS,normalize(bevelVector));
}


surface cglSurfaceCeramicTiles(
	color tile_color = color(0.2,0.35,0.5),
	color grout_color = color(0.8,0.8,0.8),
	float specular_mix = 0.5,
	float color_var = 0.0,
	float IOR = 1.5,
	float tile_base_roughness = 0.3,
	float tile_gloss_roughness = 0.001,
	float roughnessVar = 0.0,
	float grout_roughness = 0.5,
	float tile_bump_mult = 1.0,
	vector coords = vector(u,v,0),
	vector tiling = vector(0.1,0.1,0.1),
	vector grout_size = vector(0.01,0.01,0.01),
	vector bevel_size = vector(0.01,0.01,0.01),
	output closure color bsdf = 0)
{
	vector tiledCoords = getTiledCoords(coords, tiling); 
	normal nrm = getBevelNormal(grout_size, bevel_size, tiledCoords, tile_bump_mult);
	float A, B;
	float c = fabs(dot(I, nrm));
	float g = IOR * IOR - 1 + c * c;
	float Fr = 1.0;
	if (g > 0) {
		g = sqrt(g);
		A = (g - c) / (g + c);
		B = (c * (g + c) - 1) / (c * (g - c) + 1);
		Fr = 0.5 * A * A * (1 + B * B);
	}
	
	float tileMask = getTileGroutMask(grout_size, tiledCoords);
	color finalColor = mix(grout_color, tile_color, tileMask);
	float finalRoughness = mix(grout_roughness, tile_base_roughness, tileMask);
	
	//bump(tiledCoords*0.1);
	closure color diff = finalColor * diffuse (nrm);
	closure color baseSpec = microfacet ("ggx", nrm, vector(0,0,1), finalRoughness, finalRoughness, 0, 0);
	closure color coatSpec = microfacet ("ggx", nrm, vector(0,0,1), tile_gloss_roughness, tile_gloss_roughness, 0, 0);
	bsdf = ((diff * (1 - Fr) + baseSpec * (Fr * specular_mix)) * (1 - Fr)) + coatSpec * (Fr * (1 - specular_mix));
}