/* 
 * CG-Lion Surface-Car-Paint OSL shader written by Oded Erell (c)2020
 *
 * Description:
 * Outputs a car-paint material (surface shader) combining 3 layers:
 * Base: A blend of diffuse/metallic shading with a view-angle color mix
 * Metallic flakes: Distance blended procedural metallic flakes
 * Clear coat: Glossy clear coat layer with built-in procedural bump irregularity
 *
 * This shader was tested in the following renderers:
 * Cycles for Blender 2.83 (CPU)
 * Arnold 6 for Maya 2020 (CPU)
 * V-Ray Next for 3ds max 2020 (CPU)
 */

#include "stdosl.h"

// Calculates simplified Fresnel reflection weight (Schlick's approximation)
float simple_fresnel(float i_angle, float ior)
[[ string help = "Calculate Fresnel reflection weight (Schlick's approximation)" ]]
{
	float a = pow((1 - ior) / (1 + ior), 2);
	return a + (1 - a) * pow(( 1 - cos(i_angle)),5);
}

// Returns tangent space matrix
matrix tangentSpace()
[[ string help = "Returns tangent space matrix" ]]
{
	vector tan = dPdu;
	vector btan = dPdv;
	vector nrm = N;
	matrix TS = matrix( tan[0]	, tan[1]	, tan[2]	, 0.0,
						btan[0]	, btan[1]	, btan[2]	, 0.0,
						nrm[0]	, nrm[1]	, nrm[2]	, 0.0,
						0.0		, 0.0		, 0.0		, 1.0);
	return TS;
}

// Calculates and returns a bump normal in tangent space from 3 float hights:
normal bumpNormal(float hp, float hu, float hv, float uv_offset, float multiplier)
{
	vector vec_p = vector( 0.0, 		0.0, 		hp * multiplier );
	vector vec_u = vector( uv_offset, 	0.0, 		hu * multiplier );
	vector vec_v = vector( 0.0, 		uv_offset, 	hv * multiplier );
	vector vec_slope_u = normalize( vec_u - vec_p );
	vector vec_slope_v = normalize( vec_v - vec_p );
	vector nrm_raw = normalize( cross( vec_slope_u, vec_slope_v ) );
	return transform(tangentSpace(),nrm_raw);
}

normal bumpNormalTest(vector pos, float dens, float mult)
{
	vector flakes_normal_raw = normalize( ( 1 - mult ) * vector( 0.0, 0.0, 1.0 ) + mult * ( vector(-0.5, -0.5, 0.5) + noise( "uperlin", pos * dens ) ) );
	return transform(tangentSpace(),flakes_normal_raw);
}

surface cglSurfaceCarPaint
[[ string help = "Dielectric surface combining Diffuse color and specular glossy Fresnel reflections" ]]
(
	color base_color_facing = color( 0.6, 0.03, 0.02 )
		[[ string help = "The base layer facing color" ]],
	color base_color_side = color( 0.07, 0.005, 0.02 )
		[[ string help = "The base layer side color" ]],
	float base_color_blend_curve = 1.5
		[[ string help = "The base layer color blend curve power (1 = linear)",
		float min = 0.001, float max = 5.0]],
	float base_metallic = 0.5
		[[ string help = "The metallic mix weight of the base layer",
		float min = 0.0, float max = 1.0]],
	float base_dielectric_ior = 1.5
		[[ string help = "Base layer dielectric ior (also serves as metallic grasing angle reflection blend)",
		float min = 1.0, float max = 2.0]],
	float base_layer_roughness = 0.25
		[[ string help = "The base layer metallic and specular roughness",
		float min = 0.0, float max = 0.5]],
	float metallic_flakes_weight = 1.0
		[[ string help = "Metallic flakes overall mix weight",
		float min = 0.0, float max = 1.0]],
	color metallic_flakes_color = color( 0.8, 0.2, 0.1 )
		[[ string help = "Metallic flakes color" ]],
	float metallic_flakes_density = 1.0
		[[ string help = "Metallic flakes pattern density",
		float min = 0.001, float max = 1000.0]],
	float metallic_flakes_size = 0.3
		[[ string help = "Metallic flakes individual size (independent of pattern density)",
		float min = 0.0, float max = 0.5]],
	float metallic_flakes_roughness = 0.15
		[[ string help = "Metallic flakes metallic roughness",
		float min = 0.0, float max = 1.0]],
	float metallic_flakes_uniformity = 0.5
		[[ string help = "The amount at which the metallic flakes conform to original surface nornal direction",
		float min = 0.0, float max = 5.0]],
	float metallic_flakes_distance_fade = 2.0
		[[ string help = "Distance at which the metallic flakes fade completely",
		float min = 0.0, float max = 1000.0]],
	float metallic_flakes_distance_full = 0.5
		[[ string help = "Distance at which the metallic flakes are fully visible",
		float min = 0.0, float max = 1000.0]],
	float clear_coat_weight = 1.0
		[[ string help = "Clear coat layer weight",
		float min = 0.0, float max = 1.0]],
	float clear_coat_ior = 1.6
		[[ string help = "The dielectric Refractive Index of clear coat layer",
		float min = 1.0, float max = 5.0]],
	float clear_coat_roughness = 0.002
		[[ string help = "Clear coat specular roughness",
		float min = 0.0, float max = 1.0]],
	float clear_coat_bump_strength = 0.5
		[[ string help = "Clear coat procedural bump strength",
		float min = 0.0, float max = 100.0]],
	float clear_coat_bump_density = 1.0
		[[ string help = "Clear coat procedural bump density",
		float min = 0.0001, float max = 10000.0]],
	float clear_coat_bump_uv_offset = 0.001
		[[ string help = "Clear coat procedural bump - distance between hight samples",
		float min = 0.0, float max = 1.0]],
	float system_scale = 1.0
		[[ string help = "Meter based system units scale",
		float min = 0.001, float max = 1000.0]],
	output closure color surface_out = 0
		[[ string help = "Final surface output" ]]
) 
{
	// Calculate incident surface view angle
	float incident_angle = acos(abs(dot(-I, N)));
	// Get shading position in object-space:
	point os_pos = transform("common", "object", P) * system_scale;
	// Get shading tangents in object-space:
	point os_tan_u = transform("common", "object", dPdu) * system_scale;
	point os_tan_v = transform("common", "object", dPdv) * system_scale;

	// Base layer:
	// Calculate base layer Fresnel (Schlick) specular mix:
	float base_fr = simple_fresnel(incident_angle, base_dielectric_ior);
	// Calculate the linear facing ratio between 0 - 90 degrees (in randians):
	float facing_ratio = incident_angle / M_PI_2;
	// Apply power curve to the calculated facing ratio:
	float facing_ratio_curved = pow(facing_ratio, base_color_blend_curve);
	// Mix the base layer color:
	color base_color_final = ((base_color_facing * (1 - facing_ratio_curved)) + (base_color_side * facing_ratio_curved));

	// Metallic flakes layer:
	// Apply internal factor to flakes pattern scale
	float flakes_scale = metallic_flakes_density * 1000;
	// Calculate camera dostance for shading point:
	float cam_dist = length( P - point("camera",0.0, 0.0, 0.0) ) * system_scale;
	// Calculate flakes view distance fade:
	float flakes_distance_blend = 1.0 - clamp( cam_dist - metallic_flakes_distance_full, 0.0, 1.0) / ( metallic_flakes_distance_fade - metallic_flakes_distance_full );
	// Calculate metallic flakes final mix weight:
	float flakes_weight = metallic_flakes_weight * flakes_distance_blend;
	float flakes_mask = ( noise("usimplex", os_pos * flakes_scale) >= (1.0 - metallic_flakes_size) ) * flakes_weight;
	vector flakes_normal_raw = normalize( vector(-0.5, -0.5, metallic_flakes_uniformity) + noise( "cell", os_pos * flakes_scale ) );
	normal flakes_normal = transform(tangentSpace(),flakes_normal_raw);

	// Clear coat layer:
	// Clear coat bump internal scale factor:
	float coat_bump_scale = clear_coat_bump_density * 100;
	// Generate 3 height object-space perlin-noise  height samples:
	float uv_offset = clear_coat_bump_uv_offset * ( 1.0 / system_scale );
	float hp = noise( "uperlin", os_pos * coat_bump_scale );
	float hu = noise( "uperlin", ( os_pos + ( os_tan_u * uv_offset ) ) * coat_bump_scale );
	float hv = noise( "uperlin", ( os_pos + ( os_tan_u * uv_offset ) ) * coat_bump_scale );
	// Caculate clear coat normals:
	//normal clear_coat_normal = bumpNormal( hp, hu, hv, uv_offset, clear_coat_bump_strength );
	normal clear_coat_normal = bumpNormalTest( os_pos, coat_bump_scale, clear_coat_bump_strength );
	float clear_coat_incident_angle = acos(abs(dot(-I, clear_coat_normal)));
	// Caculate clear coat Fresnel (Schlick):
	float clear_coat_fr = simple_fresnel(clear_coat_incident_angle, clear_coat_ior);

	// Define Closures (BSDF's) and final shader output:
	closure color base_layer_dielectric = base_color_final * diffuse(N);
	closure color base_layer_metallic = base_color_final * microfacet ("ggx", N, vector(0,0,1), base_layer_roughness, base_layer_roughness, 0, 0);
	closure color base_layer = base_layer_dielectric * (1 - base_metallic) + base_layer_metallic * base_metallic;
	base_layer = base_layer * (1 - base_fr) + microfacet ("ggx", N, vector(0,0,1), base_layer_roughness, base_layer_roughness, 0, 0) * base_fr;
	closure color metallic_flakes_layer = metallic_flakes_color * microfacet ("ggx", flakes_normal, vector(0,0,1), metallic_flakes_roughness, metallic_flakes_roughness, 0, 0);
	closure color base_Plus_flakes = base_layer * (1 - flakes_mask) + metallic_flakes_layer * flakes_mask;
	closure color clear_coat_layer = microfacet ("ggx", clear_coat_normal, vector(0,0,1), clear_coat_roughness, clear_coat_roughness, 0, 0);
	float clear_coat_final_weight = clear_coat_fr * clear_coat_weight;
	surface_out = base_Plus_flakes * (1.0 - clear_coat_final_weight) + clear_coat_layer * clear_coat_final_weight;
}