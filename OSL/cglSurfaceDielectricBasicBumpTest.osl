/* 
 * CG-Lion Surface-Dielectric-Basic OSL shader written by Oded Erell (c)2020
 *
 * Description:
 * Outputs a Dielectric surface combining Diffuse color and glossy Fresnel reflections.
 * Parameters:
 * diffuse_color: The Diffuse color of the material.
 * IOR: The Refractive Index of the material.
 * roughness: Specular reflection Roughness.
 * normal: Normal vector input.
 *
 * This shader was tested in the following renderers:
 * Cycles for Blender 2.83 (CPU)
 * Arnold 6 for Maya 2020 (CPU)
 * V-Ray Next for 3ds max 2020 (CPU)
 */

#include "stdosl.h"

// Returns tangent space matrix
matrix tangentSpace()
[[ string help = "Returns tangent space matrix" ]]
{
	vector tan = dPdu;
	vector btan = dPdv;
	vector nrm = N;
	matrix TS = matrix( tan[0]	, tan[1]	, tan[2]	, 0.0,
						btan[0]	, btan[1]	, btan[2]	, 0.0,
						nrm[0]	, nrm[1]	, nrm[2]	, 0.0,
						0.0		, 0.0		, 0.0		, 1.0);
	return TS;
}

// Calculates and returns a bump normal in tangent space from 3 float hights:
normal bumpNormal(float hp, float hu, float hv, float uv_offset, float multiplier)
{
	vector vec_p = vector( 0.0, 		0.0, 		hp * multiplier );
	vector vec_u = vector( uv_offset, 	0.0, 		hu * multiplier );
	vector vec_v = vector( 0.0, 		uv_offset, 	hv * multiplier );
	vector vec_slope_u = normalize( vec_u - vec_p );
	vector vec_slope_v = normalize( vec_v - vec_p );
	vector nrm_raw = normalize( cross( vec_slope_u, vec_slope_v ) );
	return transform(tangentSpace(),nrm_raw);
}

float simple_fresnel(float ior, normal nrm)
[[ string help = "Calculate Fresnel reflection weight (Schlick)" ]]
{
	float r = pow( ( 1 - ior ) / ( 1 + ior ), 2.0 );
	return r + ( 1 - r ) * pow( 1 - fabs( dot( -I, nrm ) ), 5.0 );
}

surface cglSurfaceDielectricBasic
[[ string help = "Dielectric surface combining Diffuse color and specular glossy Fresnel reflections" ]]
(
	color diffuse_color = color(0.5)
		[[ string help = "The Diffuse color of the material" ]],
	float IOR = 1.5
		[[ string help = "The Refractive Index of the material",
		float min = 1.0, float max = 5.0]],
	float roughness = 0.0
		[[ string help = "Specular reflection Roughness",
		float min = 0.0, float max = 1.0]],
	normal Normal = N
		[[ string help = "Normal vector input" ]],
	output closure color surface_out = 0
) 
{
	float Fr = simple_fresnel(IOR, Normal);
	surface_out = (diffuse_color * diffuse (Normal)) * (1 - Fr) + (microfacet ("ggx", Normal, vector(0,0,1), roughness, roughness, 0, 0)) * Fr;
}